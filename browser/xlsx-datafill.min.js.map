{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/XlsxDataFill.js","src/XlsxPopulateAccess.js"],"names":["f","exports","module","define","amd","window","global","self","this","XlsxDataFill","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_2","defaultOpts","templateRegExp","RegExp","fieldSplitter","joinText","callbacksMap","","data","keys","accessor","opts","_classCallCheck","_opts","defaultsDeep","_rowSizes","_colSizes","_access","newOpts","merge","options","extractor","extractParts","split","path","handler","cell","template","_this","styles","each","pair","startsWith","name","substr","val","extractValues","setStyle","reMatch","cellTextValue","match","parts","map","trim","iters","reference","buildRef","iterators","cellSize","padding","v","parseInt","s","cb","_this2","allTemplates","forAllCells","parseTemplate","push","sort","b","cellRef","forEach","root","_this3","_this$parseExtractor","parseExtractor","Array","isArray","undefined","sizes","entry","join","get","idx","_this4","iter","transposed","parsedIter","inRoot","extractData","_typeof","values","unshift","_this5","entrySize","value","concat","chunk","getCellRange","ri","ci","setValue","copyStyle","copySize","applyDataStyle","aFill","mainCell","_this6","theData","dependents","nextCell","sizeMaxxer","Math","max","d","inFill","inCell","offsetCell","offset","innerSize","applyFill","processed","putValues","rowOffset","colOffset","rng","setRangeMerged","cellDistance","_this7","dataFills","collectTemplates","refFill","fill","XlsxPopulateAccess","_","_RichText","workbook","XlsxPopulate","_workbook","RichText","cellValue","text","from","to","rowNumber","columnNumber","cellAddr","address","theSize","sheet","_mergeCells","range","rangeAddr","attributes","ref","includeSheetName","adr","sheetId","activeSheet","rangeTo","relativeCell","rows","cols","status","merged","sheets","usedRange","dest","src","_styleId","row","col","height","column","width","style"],"mappings":"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","file":"xlsx-datafill.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\n\nconst _ = require('lodash');\nconst defaultOpts = {\n    templateRegExp: new RegExp(/\\{\\{([^}]*)\\}\\}/),\n    fieldSplitter: \"|\",\n    joinText: \",\",\n    callbacksMap: {\n        \"\": data => _.keys(data)\n    }\n};\n\n/**\n * Data fill engine.\n */\nclass XlsxDataFill {\n    /**\n     * Constructs a new instance of XlsxDataFill with given options.\n     * @param {object} accessor An instance of XLSX data accessing class.\n     * @param {{}} opts Options to be used during processing.\n     * @param {RegExp} opts.templateRegExp The regular expression to be used for template parsing.\n     * @param {string} opts.fieldSplitter The string to be expected as template field splitter.\n     * @param {string} opts.joinText The string to be used when extracting array values.\n     * @param {object.<string, function>} opts.callbacksMap A map of handlers to be used for data extraction.\n     */\n    constructor(accessor, opts) {\n        this._opts = _.defaultsDeep({}, opts, defaultOpts);\n        this._rowSizes = {};\n        this._colSizes = {};\n        this._access = accessor;\n    }\n\n    /**\n     * Setter/getter for XlsxDataFill's options as set during construction.\n     * @param {{}|null} newOpts If set - the news options to be used.\n     * @returns {XlsxDataFill|{}} The required options or XlsxDataFill (in set mode) for chaining.\n     */\n    options(newOpts) {\n        if (newOpts !== null) {\n            _.merge(this._opts, newOpts);\n            this._access.options(this._opts);\n            return this;\n        } else\n            return this._opts;\n    }\n\n    /**\n     * Parses the provided extractor (ot iterator) string to find a callback id inside, if present.\n     * @param {string} extractor The iterator/extractor string to be investigated.\n     * @returns {object.<string, function>} A { `path`, `handler` } object representing the JSON path\n     * ready for use and the provided `handler` _function_ - ready for invoking, if such is provided.\n     * If not - the `path` property contains the provided `extractor`, and the `handler` is `null`.\n     */\n    parseExtractor(extractor) {\n        // A specific extractor can be specified after semilon - find and remember it.\n        const extractParts = extractor.split(\":\");\n\n        return extractParts.length == 1\n            ? { path: extractor, handler: null }\n            : {\n                path: extractParts[0],\n                handler: this._opts.callbacksMap[extractParts[1]]\n            };\n    }\n\n    /**\n     * Applies the style part of the template onto a given cell.\n     * @param {Cell} cell The destination cell to apply styling to.\n     * @param {{}} data The data chunk for that cell.\n     * @param {{}} template The template to be used for that cell.\n     * @returns {DataFiller} For invocation chaining.\n     */\n    applyDataStyle(cell, data, template) {\n        const styles = template.styles;\n        \n        if (styles && data) {\n            _.each(styles, pair => {\n                if (_.startsWith(pair.name, \":\")) {\n                    const handler = this._opts.callbacksMap[pair.name.substr(1)];\n                    if (typeof handler === 'function')\n                        handler(data, cell, this._opts);\n                } else {\n                    const val = this.extractValues(data, pair.extractor, cell);\n                    if (val)\n                        this._access.setStyle(cell, pair.name, val);\n                }\n            });\n        }\n\n        return this;\n    }\n\n\n    /**\n     * Parses the contents of the cell into a valid template info.\n     * @param {Cell} cell The cell containing the template to be parsed.\n     * @returns {{}} The parsed template.\n     * @description This method builds template info, taking into account the supplied options.\n     */\n    parseTemplate(cell) {\n        // The options are in `this` argument.\n        const reMatch = (this._access.cellTextValue(cell) || '').match(this._opts.templateRegExp);\n        \n        if (!reMatch) return null;\n    \n        const parts = reMatch[1].split(this._opts.fieldSplitter).map(_.trim),\n            iters = parts[1].split(/x|\\*/).map(_.trim),\n            styles = !parts[4] ? null : parts[4].split(\",\");\n\n        return {\n            reference: this._access.buildRef(cell, _.trim(parts[0])),\n            iterators: iters,\n            extractor: parts[2] || \"\",\n            cell: cell,\n            cellSize: this._access.cellSize(cell),\n            padding: (parts[3] || \"\").split(/:|,|x|\\*/).map(v => parseInt(v) || 0),\n            styles: !styles ? null : _.map(styles, s => {\n                const pair = _.trim(s).split(\"=\");\n                return { name: _.trim(pair[0]), extractor: _.trim(pair[1]) };\n            })\n        };\n    }\n\n    /**\n     * Searches the whole workbook for template pattern and constructs the templates for processing.\n     * @param {Function} cb The callback to be invoked on each templated, after they are sorted.\n     * @returns {undefined}\n     * @description The templates collected are sorted, based on the intra-template reference - if one template\n     * is referring another one, it'll appear _later_ in the returned array, than the referred template.\n     * This is the order the callback is being invoked on.\n     */\n    collectTemplates(cb) {\n        const allTemplates = [];\n    \n        this._access.forAllCells(cell => {\n            const template = this.parseTemplate(cell);\n            if (template)\n                allTemplates.push(template);\n        });\n        \n        return allTemplates\n            .sort((a, b) => a.reference == this._access.cellRef(b.cell) ? 1 : b.reference == this._access.cellRef(a.cell) ? -1 : 0)\n            .forEach(cb);\n    }\n\n    /**\n     * Extracts the value(s) from the provided data `root` to be set in the provided `cell`.\n     * @param {{}} root The data root to be extracted values from.\n     * @param {string} extractor The extraction string provided by the template. Usually a JSON path within the data `root`.\n     * @param {Cell} cell A reference cell, if such exists.\n     * @returns {string|Array|Array.<Array.<*>>} The value to be used.\n     * @description This method is used even when a whole - possibly rectangular - range is about to be set, so it can\n     * return an array of arrays.\n     */\n    extractValues(root, extractor, cell) {\n        const { path, handler } = this.parseExtractor(extractor);\n\n        if (!Array.isArray(root))\n            root = _.get(root, path, root);\n        else if (root.sizes !== undefined)\n            root = !extractor ? root : _.map(root, entry => this.extractValues(entry, extractor, cell));\n        else if (!handler)\n            return root.join(this._opts.joinText || \",\");\n\n        return !handler ? root : handler(root, cell, this._opts);\n    }\n\n    /**\n     * Extracts an array (possibly of arrays) with data for the given fill, based on the given\n     * root object.\n     * @param {{}} root The main reference object to apply iterators to.\n     * @param {Array} iterators List of iterators - string JSON paths inside the root object.\n     * @param {Number} idx The index in the iterators array to work on.\n     * @returns {Array|Array.<Array>} An array (possibly of arrays) with extracted data.\n     */\n    extractData(root, iterators, idx) {\n        let iter = iterators[idx],\n            sizes = [],\n            transposed = false,\n            data = null;\n\n        if (iter == '1') {\n            transposed = true;\n            iter = iterators[++idx];\n        }\n\n        if (!iter) return root;\n\n        // A specific extractor can be specified after semilon - find and remember it.\n        const parsedIter = this.parseExtractor(iter);\n\n        data = _.get(root, parsedIter.path, root);\n        \n        if (typeof parsedIter.handler === 'function')\n            data = parsedIter.handler.call(null, data, null, this._opts);\n\n        if (idx < iterators.length - 1) {\n            data = _.map(data, inRoot => this.extractData(inRoot, iterators, idx + 1));\n            sizes = data[0].sizes;\n        } else if (!Array.isArray(data) && typeof data === 'object')\n            data = _.values(data);\n\n        sizes.unshift(transposed ? -data.length : data.length);\n        data.sizes = sizes;\n        return data;\n    }\n\n    /**\n     * Put the data values into the proper cells, with correct extracted values.\n     * \n     * @param {{}} cell The starting cell for the data to be put.\n     * @param {Array} data The actual data to be put. The values will be _extracted_ from here first.\n     * @param {{}} template The template that is being implemented with that data fill.\n     * @returns {Array} Matrix size that this data has occupied on the sheet [rows, cols].\n     */\n    putValues(cell, data, template) {\n        let entrySize = data.sizes,\n            value = this.extractValues(data, template.extractor, cell);\n\n        // make sure, the \n        if (!entrySize || !entrySize.length) {\n            this._access\n                .setValue(cell, value)\n                .copyStyle(cell, template.cell)\n                .copySize(cell, template.cell);\n            this.applyDataStyle(cell, data, template);\n            entrySize = template.cellSize;\n        } else if (entrySize.length <= 2) {\n            // Normalize the size and data.\n            if (entrySize[0] < 0) {\n                entrySize = [1, -entrySize[0]];\n                value = [value];\n            } else if (entrySize.length == 1) {\n                entrySize = entrySize.concat([1]);\n                value = _.chunk(value, 1);\n            }\n\n            this._access.getCellRange(cell, entrySize[0] - 1, entrySize[1] - 1).forEach((cell, ri, ci) => {\n                this._access\n                    .setValue(cell, value[ri][ci])\n                    .copyStyle(cell, template.cell)\n                    .copySize(cell, template.cell);\n                this.applyDataStyle(cell, data[ri][ci], template);\n            });\n        } else {\n            // TODO: Deal with more than 3 dimensions case.\n        }\n\n        return entrySize;\n    }\n\n    /**\n     * Apply the given filter onto the sheet - extracting the proper data, following dependent fills, etc.\n     * @param {{}} aFill The fill to be applied, as constructed in the @see populate methods.\n     * @param {{}} root The data root to be used for data extraction.\n     * @param {Cell} mainCell The starting cell for data placement procedure.\n     * @returns {Array} The size of the data put in [row, col] format.\n     */\n    applyFill(aFill, root, mainCell) {\n        const template = aFill.template,\n            theData = this.extractData(root, template.iterators, 0);\n\n        let entrySize = [1, 1];\n\n        if (!aFill.dependents || !aFill.dependents.length)\n            entrySize = this.putValues(mainCell, theData, template);\n        else {\n            let nextCell = mainCell;\n            const sizeMaxxer = (val, idx) => entrySize[idx] = Math.max(entrySize[idx], val);\n\n            for (let d = 0; d < theData.length; ++d) {\n                const inRoot = theData[d];\n\n                for (let f = 0; f < aFill.dependents.length; ++f) {\n                    const inFill = aFill.dependents[f],\n                        inCell = this._access.offsetCell(nextCell, inFill.offset[0], inFill.offset[1]),\n                        innerSize = this.applyFill(inFill, inRoot, inCell);\n\n                    _.forEach(innerSize, sizeMaxxer);\n                    inFill.processed = true;\n                }\n\n                // Now we have the inner data put and the size calculated.\n                _.forEach(this.putValues(nextCell, inRoot, template), sizeMaxxer);\n\n                let rowOffset = entrySize[0],\n                    colOffset = entrySize[1];\n\n                // Make sure we grow only on one dimension.\n                if (theData.sizes[0] < 0) {\n                    rowOffset = 0;\n                    entrySize[1] = 1;\n                } else {\n                    colOffset = 0;\n                    entrySize[0] = 1;\n                }\n\n                if (rowOffset > 1 || colOffset > 1) {\n                    const rng = this._access.getCellRange(nextCell, Math.max(rowOffset - 1, 0), Math.max(colOffset - 1, 0));\n                    this._access.setRangeMerged(rng, true);\n                    rng.forEach(cell => this._access.copySize(cell, template.cell));\n                }\n\n                // Finally, calculate the next cell.\n                nextCell = this._access.offsetCell(nextCell, rowOffset + template.padding[0], colOffset + template.padding[1] || 0);\t\n            }\n\n            // Now recalc combined entry size.\n            _.forEach(this._access.cellDistance(mainCell, nextCell), sizeMaxxer);\n        }\n\n        return entrySize;\n    }\n\n    /**\n     * The main entry point for whole data population mechanism.\n     * @param {{}} data The data to be applied.\n     * @returns {XlsxDataFill} For invocation chaining.\n     */\n    fillData(data) {\n        const dataFills = {};\n\t\n        // Build the dependency connections between templates.\n        this.collectTemplates(template => {\n            const aFill = {  \n                template: template, \n                dependents: [],\n                processed: false\n            };\n    \n            if (template.reference) {\n                const refFill = dataFills[template.reference];\n                \n                refFill.dependents.push(aFill);\n                aFill.offset = this._access.cellDistance(refFill.template.cell, template.cell);\n            }\n    \n            dataFills[this._access.cellRef(template.cell)] = aFill;\n        });\n    \n        // Apply each fill onto the sheet.\n        _.each(dataFills, fill => {\n            if (!fill.processed)\n                this.applyFill(fill, data, fill.template.cell);\n        });\n\n        return this;\n    }\n}\n\n/**\n * The built-in accessor based on xlsx-populate npm module\n * @type {XlsxPopulateAccess}\n */\nXlsxDataFill.XlsxPopulateAccess = require('./XlsxPopulateAccess');\n\nmodule.exports = XlsxDataFill;\n","\"use strict\";\n\nconst _ = require('lodash');\n\nconst allStyles = [\n    \"bold\", \n    \"italic\", \n    \"underline\", \n    \"strikethrough\", \n    \"subscript\", \n    \"superscript\", \n    \"fontSize\", \n    \"fontFamily\", \n    \"fontGenericFamily\", \n    \"fontScheme\", \n    \"fontColor\", \n    \"horizontalAlignment\", \n    \"justifyLastLine\", \n    \"indent\", \n    \"verticalAlignment\", \n    \"wrapText\", \n    \"shrinkToFit\", \n    \"textDirection\", \n    \"textRotation\", \n    \"angleTextCounterclockwise\", \n    \"angleTextClockwise\", \n    \"rotateTextUp\", \n    \"rotateTextDown\", \n    \"verticalText\", \n    \"fill\", \n    \"border\", \n    \"borderColor\", \n    \"borderStyle\", \n    \"leftBorder\", \"rightBorder\", \"topBorder\", \"bottomBorder\", \"diagonalBorder\", \n    \"leftBorderColor\", \"rightBorderColor\", \"topBorderColor\", \"bottomBorderColor\", \"diagonalBorderColor\", \n    \"leftBorderStyle\", \"rightBorderStyle\", \"topBorderStyle\", \"bottomBorderStyle\", \"diagonalBorderStyle\", \n    \"diagonalBorderDirection\", \n    \"numberFormat\"\n];\n\nlet _RichText = null;\n\n\n// const XlsxPopulate = require('xlsx-populate');\n\n/**\n * Data fill routines wrapper.\n * @ignore\n */\nclass XlsxPopulateAccess {\n    /**\n     * Constructs a new instance of XlsxSmartTemplate with given options.\n     * @param {Workbook} workbook - The workbook to be accessed.\n     * @param {XlsxPopulate} XlsxPopulate - The actual xlsx-populate library object.\n     * @description The `XlsxPopulate` object need to be passed in order to extract\n     * certain information from it, _without_ referring the whole library, and thus\n     * making the `xlsx-datafill` package dependent on it.\n     */\n    constructor(workbook, XlsxPopulate) {\n        this._workbook = workbook;\n        this._rowSizes = {};\n        this._colSizes = {};\n    \n        _RichText = XlsxPopulate.RichText;\n    }\n\n    /**\n     * Returns the configured workbook for direct XlsxPopulate manipulation.\n     * @returns {Workbook} The workbook involved.\n     */\n    workbook() {\n        return this._workbook; \n    }\n\n    /**\n     * Gets the textual representation of the cell value.\n     * @param {Cell} cell - The cell to retrieve the value from.\n     * @returns {string} The textual representation of cell's contents.\n     */\n    cellTextValue(cell) {\n        const cellValue = cell.value();\n        return cellValue instanceof _RichText ? cellValue.text() : cellValue;\n    }\n\n    /**\n     * Measures the distance, as a vector between two given cells.\n     * @param {Cell} from The first cell.\n     * @param {Cell} to The second cell.\n     * @returns {Array.<Number>} An array with two values [<rows>, <cols>], representing the distance between the two cells.\n     */\n    cellDistance(from, to) {\n        return [\n            to.rowNumber() - from.rowNumber(),\n            to.columnNumber() - from.columnNumber()\n        ];\n    }\n\n    /**\n     * Determines the size of cell, taking into account if it is part of a merged range.\n     * @param {Cell} cell The cell to be investigated.\n     * @returns {Array.<Number>} An array with two values [<rows>, <cols>], representing the occupied size.\n     */\n    cellSize(cell) {\n        const cellAddr = cell.address();\n        let theSize = [1, 1];\n    \n        _.forEach(cell.sheet()._mergeCells, range => {\n            const rangeAddr = range.attributes.ref.split(\":\");\n            if (rangeAddr[0] == cellAddr) {\n                theSize = this.cellDistance(cell, cell.sheet().cell(rangeAddr[1]));\n                ++theSize[0];\n                ++theSize[1];\n                return false;\n            }\n        });\n    \n        return theSize;\n    }\n\n    /**\n     * Creates a reference Id for a given cell, based on its sheet and address.\n     * @param {Cell} cell The cell to create a reference Id to.\n     * @returns {string} The id to be used as a reference for this cell.\n     */\n    cellRef(cell) {\n        return cell.address({ includeSheetName: true });\n    }\n\n    /**\n     * Build a reference string for a cell identified by @param adr, from the @param cell.\n     * @param {Cell} cell A cell that is a base of the reference.\n     * @param {string} adr The address of the target cell, as mentioned in @param cell.\n     * @returns {string} A reference string identifying the target cell uniquely.\n     */\n    buildRef(cell, adr) {\n        return adr ? cell.sheet().cell(adr).address({ includeSheetName: true }) : null;\n    }\n\n    /**\n     * Retrieves a given cell from a given sheet (or an active one).\n     * @param {string|object|array} address The cell adress to be used\n     * @param {string|idx} sheetId The id/name of the sheet to retrieve the cell from. Defaults to an active one.\n     * @returns {Cell} A reference to the required cell.\n     */\n    getCell(address, sheetId) {\n        const theSheet = sheetId == null ? this._workbook.activeSheet() : this._workbook.sheet(sheetId);\n        return theSheet.cell(address);\n    }\n\n    /**\n     * Constructs and returns the range starting from the given cell and spawning given rows and cells.\n     * @param {Cell} cell The starting cell of the range.\n     * @param {Number} rowOffset Number of rows away from the starting cell. 0 means same row.\n     * @param {Number} colOffset Number of columns away from the starting cell. 0 means same column.\n     * @returns {Range} The constructed range.\n     */\n    getCellRange(cell, rowOffset, colOffset) {\n        return cell.rangeTo(cell.relativeCell(rowOffset, colOffset));\n    }\n\n    /**\n     * Gets the cell at a certain offset from a given one.\n     * @param {Cell} cell The reference cell to make the offset from.\n     * @param {int} rows Number of rows to offset.\n     * @param {int} cols Number of columns to offset.\n     * @returns {Cell} The resulting cell.\n     */\n    offsetCell(cell, rows, cols) {\n        return cell.relativeCell(rows, cols);\n    }\n\n    /**\n     * Merge or split range of cells.\n     * @param {Range} range The range, as returned from @see getCellRange().\n     * @param {boolean} status The merged status to be set.\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    setRangeMerged(range, status) {\n        range.merged(status);\n        return this;\n    }\n\n    /**\n     * Iterate over all used cells of the given workbook.\n     * @param {function} cb The callback to be invoked with `cell` argument for each used cell.\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    forAllCells(cb) {\n        this._workbook.sheets().forEach(sheet => sheet.usedRange().forEach(cb));\n        return this;\n    }\n\n    /**\n     * Copies the styles from `src` cell to the `dest`-ination one.\n     * @param {Cell} dest Destination cell.\n     * @param {Cell} src Source cell.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    copyStyle(dest, src) {\n        if (src == dest) return this;\n\n        dest._styleId = src._styleId;\n        \n        // if (src._style)\n        //     dest._style = _.merge(new src._style.constructor(), src._style);\n        \n        return this;\n    }\n\n    /**\n     * Resize the column and row of the destination cell, if not changed already.\n     * @param {Cell} dest The destination cell which row and column to resize.\n     * @param {Cell} src The source (template) cell to take the size from.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    copySize(dest, src) {\n        const row = dest.rowNumber(),\n            col = dest.columnNumber();\n\n        if (this._rowSizes[row] === undefined)\n            dest.row().height(this._rowSizes[row] = src.row().height());\n        \n        if (this._colSizes[col] === undefined)\n            dest.column().width(this._colSizes[col] = src.column().width());\n\n        return this;\n    }\n\n    /**\n     * Sets a value in the cell.\n     * @param {Cell} cell The cell to be operated.\n     * @param {string} value The string value to be set inside.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    setValue(cell, value) {\n        cell.value(value);\n        return this;\n    }\n\n    /**\n     * Sets a named style of a given cell.\n     * @param {Cell} cell The cell to be operated.\n     * @param {string} name The name of the style property to be set.\n     * @param {string|object} value The value for this property to be set.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    setStyle(cell, name, value) {\n        cell.style(name, value);\n        return this;\n    }\n}\n\nmodule.exports = XlsxPopulateAccess;\n"]}