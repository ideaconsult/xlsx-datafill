{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/XlsxDataFill.js","src/XlsxPopulateAccess.js"],"names":["f","exports","module","define","amd","window","global","self","this","XlsxDataFill","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_2","defaultOpts","templateRegExp","fieldSplitter","joinText","mergeCells","duplicateCells","followFormulae","copyStyle","callbacksMap","","data","keys","$","values","refRegExp","accessor","opts","_classCallCheck","_opts","defaultsDeep","_rowSizes","_colSizes","_access","newOpts","merge","_this","dataFills","collectTemplates","template","aFill","dependents","formulas","processed","reference","refFill","concat","formula","push","offset","cellDistance","cell","id","each","fill","extractor","applyFill","handlerName","handlerFn","extractParts","split","trim","path","handler","getHandler","_this2","styles","pair","startsWith","name","substr","val","extractValues","setCellStyle","JSON","parse","clone","value","cellValue","reMatch","match","cellType","parts","map","cellRef","buildRef","iterators","cellSize","padding","v","parseInt","s","list","sorted","related","freeList","_t","shift","apply","_toConsumableArray","xor","join","cb","_this3","allTemplates","forAllCells","parseTemplate","sortTemplates","forEach","root","_this4","_this$parseExtractor","parseExtractor","Array","isArray","undefined","sizes","entry","get","idx","_this5","iter","transposed","parsedIter","_typeof","inRoot","extractData","unshift","_this6","entrySize","chunk","getCellRange","ri","ci","setCellValue","applyDataStyle","mainCell","_this7","theData","nextCell","sizeMaxxer","Math","max","_loop","d","inFill","inCell","offsetCell","putValues","rowOffset","colOffset","rowPadding","colPadding","rng","getTemplateOpts","mergeCell","rangeMerged","duplicateCell","applyFormula","size","newFormula","newRef","from","getCell","rangeRef","index","shiftFormula","setCellFormula","setRangeFormula","XlsxPopulateAccess","version","_","_RichText","workbook","XlsxPopulate","_workbook","RichText","theValue","text","hyperlink","Date","trimStart","to","rowNumber","columnNumber","cellAddr","address","theSize","sheet","_mergeCells","range","rangeAddr","attributes","ref","style","withSheet","includeSheetName","adr","sheetId","activeSheet","rangeTo","relativeCell","rows","cols","status","merged","sheets","theRange","usedRange","dest","src","_style","_styleId","destSheetId","rowId","colId","row","height","column","width"],"mappings":"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","file":"xlsx-datafill.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\n\nconst _ = require('lodash');\n\nconst defaultOpts = {\n    templateRegExp: /\\{\\{([^}]*)\\}\\}/,\n    fieldSplitter: \"|\",\n    joinText: \",\",\n    mergeCells: true,\n    duplicateCells: false,\n    followFormulae: false,\n    copyStyle: true,\n    callbacksMap: {\n        '': data => _.keys(data),\n        $: data => _.values(data)\n    }\n};\n\nconst refRegExp = /('?([^!]*)?'?!)?([A-Z]+\\d+)(:([A-Z]+\\d+))?/;\n\n/**\n * Data fill engine, taking an instance of Excel sheet accessor and a JSON object as data, and filling the values from the latter into the former.\n */\nclass XlsxDataFill {\n    /**\n     * Constructs a new instance of XlsxDataFill with given options.\n     * @param {object} accessor An instance of XLSX spreadsheet accessing class.\n     * @param {{}} opts Options to be used during processing.\n     * @param {RegExp} opts.templateRegExp The regular expression to be used for template recognizing. \n     * Default is `/\\{\\{([^}]*)\\}\\}/`, i.e. Mustache.\n     * @param {string} opts.fieldSplitter The string to be expected as template field splitter. Default is `|`.\n     * @param {string} opts.joinText The string to be used when the extracted value for a single cell is an array, \n     * and it needs to be joined. Default is `,`.\n     * @param {string|boolean} opts.mergeCells Whether to merge the higher dimension cells in the output. Default is true.\n     * @param {string|boolean} opts.duplicateCells Whether to duplicate the content of higher dimension cells, when not merged. Default is false.\n     * @param {boolean} opts.followFormulae If a template is located as a result of a formula, whether to still process it.\n     * Default is false.\n     * @param {boolean} opts.copyStyle Copy the style of the template cell when populating. Even when `false`, the template\n     * styling _is_ applied. Default is true.\n     * @param {object.<string, function>} opts.callbacksMap A map of handlers to be used for data and value extraction.\n     * There is one default - the empty one, for object key extraction.\n     */\n    constructor(accessor, opts) {\n        this._opts = _.defaultsDeep({}, opts, defaultOpts);\n        this._rowSizes = {};\n        this._colSizes = {};\n        this._access = accessor;\n    }\n\n    /**\n     * Setter/getter for XlsxDataFill's options as set during construction.\n     * @param {{}|null} newOpts If set - the new options to be used. \n     * @see {@constructor}.\n     * @returns {XlsxDataFill|{}} The required options (in getter mode) or XlsxDataFill (in setter mode) for chaining.\n     */\n    options(newOpts) {\n        if (newOpts !== null) {\n            _.merge(this._opts, newOpts);\n            return this;\n        } else\n            return this._opts;\n    }\n\n    /**\n     * The main entry point for whole data population mechanism.\n     * @param {{}} data The data to be applied.\n     * @returns {XlsxDataFill} For invocation chaining.\n     */\n    fillData(data) {\n        const dataFills = {};\n\t\n        // Build the dependency connections between templates.\n        this.collectTemplates(template => {\n            const aFill = {  \n                template: template, \n                dependents: [],\n                formulas: [],\n                processed: false\n            };\n\n            if (template.reference) {\n                const refFill = dataFills[template.reference];\n                \n                if (!refFill) \n                    throw new Error(`Unable to find a reference '${template.reference}'!`);\n                \n                if (template.formula) \n                    refFill.formulas.push(aFill);\n                else\n                    refFill.dependents.push(aFill);\n    \n                aFill.offset = this._access.cellDistance(refFill.template.cell, template.cell);\n            }\n            dataFills[template.id] = aFill;\n        });\n    \n        // Apply each fill onto the sheet.\n        _.each(dataFills, fill => {\n            if (fill.processed)\n                return;\n            else if (fill.template.formula)\n                throw new Error(`Non-referencing formula found '${fill.extractor}'. Use a non-templated one!`);\n            else\n                this.applyFill(fill, data, fill.template.cell);\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the provided handler from the map.\n     * @param {string} handlerName The name of the handler.\n     * @returns {function} The handler function itself.\n     * @ignore\n     */\n    getHandler(handlerName) {\n        const handlerFn = this._opts.callbacksMap[handlerName];\n\n        if (!handlerFn)\n            throw new Error(`Handler '${handlerName}' cannot be found!`);\n        else if (typeof handlerFn !== 'function')\n            throw new Error(`Handler '${handlerName}' is not a function!`);\n        else \n            return handlerFn;\n    }\n\n    /**\n     * Parses the provided extractor (ot iterator) string to find a callback id inside, if present.\n     * @param {string} extractor The iterator/extractor string to be investigated.\n     * @returns {object.<string, function>} A { `path`, `handler` } object representing the JSON path\n     * ready for use and the provided `handler` _function_ - ready for invoking, if such is provided.\n     * If not - the `path` property contains the provided `extractor`, and the `handler` is `null`.\n     * @ignore\n     */\n    parseExtractor(extractor) {\n        // A specific extractor can be specified after semilon - find and remember it.\n        const extractParts = extractor.split(\":\"),\n            handlerName = _.trim(extractParts[1]);\n\n        return extractParts.length == 1\n            ? { path: extractor, handler: null }\n            : {\n                path: _.trim(extractParts[0]),\n                handler: this.getHandler(handlerName)\n            };\n    }\n\n    /**\n     * Applies the style part of the template onto a given cell.\n     * @param {Cell} cell The destination cell to apply styling to.\n     * @param {{}} data The data chunk for that cell.\n     * @param {{}} template The template to be used for that cell.\n     * @returns {DataFiller} For invocation chaining.\n     * @ignore\n     */\n    applyDataStyle(cell, data, template) {\n        const styles = template.styles;\n\n        if (this._opts.copyStyle)\n            this._access.copyStyle(cell, template.cell);\n        \n        if (styles && data) {\n            _.each(styles, pair => {\n                if (_.startsWith(pair.name, \":\")) {\n                    this.getHandler(pair.name.substr(1)).call(this._opts, data, cell);\n                } else if (!_.startsWith(pair.name, \"!\")) {\n                    const val = this.extractValues(data, pair.extractor, cell);\n                    if (val)\n                        this._access.setCellStyle(cell, pair.name, JSON.parse(val));\n                }\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Extract the options-specific parameters from the styles field and merge them with the global ones.\n     * @param {{}} template The template to extract options properties from.\n     * @returns {{}} The full options, \n     * @ignore\n     */\n    getTemplateOpts(template) {\n        if (!template.styles)\n            return this._opts;\n        \n        const opts = _.clone(this._opts);\n        _.each(template.styles, pair => {\n            if (_.startsWith(pair.name, \"!\"))\n                opts[pair.name.substr(1)] = JSON.parse(pair.extractor);\n        });\n\n        return opts;\n    }\n\n    /**\n     * Parses the contents of the cell into a valid template info.\n     * @param {Cell} cell The cell containing the template to be parsed.\n     * @returns {{}} The parsed template.\n     * @description This method builds template info, taking into account the supplied options.\n     * @ignore\n     */\n    parseTemplate(cell) {\n        const value = this._access.cellValue(cell);\n        if (value == null || typeof value !== 'string')\n            return null;\n        \n        const reMatch = value.match(this._opts.templateRegExp);\n        if (!reMatch || !this._opts.followFormulae && this._access.cellType(cell) === 'formula') \n            return null;\n    \n        const parts = reMatch[1].split(this._opts.fieldSplitter).map(_.trim),\n            styles = !parts[4] ? null : parts[4].split(\",\"),\n            extractor = parts[2] || \"\",\n            cellRef = this._access.buildRef(cell, parts[0]);\n        \n        if (parts.length < 2) \n            throw new Error(`Not enough components of the template '${reMatch[0]}'`);\n        if (!!parts[0] && !cellRef)\n            throw new Error(`Invalid reference passed: '${parts[0]}'`);\n\n        return {\n            id: this._access.cellRef(cell),\n            reference: cellRef,\n            iterators: parts[1].split(/x|\\*/).map(_.trim),\n            extractor: extractor,\n            formula: extractor.startsWith(\"=\"),\n            cell: cell,\n            cellSize: this._access.cellSize(cell),\n            padding: (parts[3] || \"\").split(/:|,|x|\\*/).map(v => parseInt(v) || 0),\n            styles: !styles ? null : _.map(styles, s => {\n                const pair = _.trim(s).split(\"=\");\n                return { name: _.trim(pair[0]), extractor: _.trim(pair[1]) };\n            })\n        };\n    }\n\n    sortTemplates(list) {\n        const sorted = [],\n            related = {},\n            map = {},\n            freeList = [];\n\n        // First, make the dependency map and add the list of non-referencing templates\n        for (let i = 0; i < list.length; ++i) {\n            const t = list[i];\n            map[t.id] = i;\n\n            if (!t.reference)\n                freeList.push(t.id);\n            else \n                (related[t.reference] = related[t.reference] || []).push(t.id);\n        }\n\n        // Now, make the actual sorting.\n        while (freeList.length > 0) {\n            const id = freeList.shift(),\n                t = list[map[id]];\n\n            sorted.push(t);\n            \n            // We use the fact that there is a single predecessor in our setup.\n            if (related[t.id])\n                freeList.push(...related[t.id]);\n        }\n\n        if (sorted.length < list.length)\n            throw new Error(`A reference cycle found, involving \"${_.map(_.xor(list, sorted), 'id').join(',')}\"!`);\n\n        return sorted;\n    }\n    \n    /**\n     * Searches the whole workbook for template pattern and constructs the templates for processing.\n     * @param {Function} cb The callback to be invoked on each templated, after they are sorted.\n     * @returns {undefined}\n     * @description The templates collected are sorted, based on the intra-template reference - if one template\n     * is referring another one, it'll appear _later_ in the returned array, than the referred template.\n     * This is the order the callback is being invoked on.\n     * @ignore\n     */\n    collectTemplates(cb) {\n        const allTemplates = [];\n    \n        this._access.forAllCells(cell => {\n            const template = this.parseTemplate(cell);\n            if (template)\n                allTemplates.push(template);\n        });\n        \n        return this.sortTemplates(allTemplates).forEach(cb);\n    }\n\n    /**\n     * Extracts the value(s) from the provided data `root` to be set in the provided `cell`.\n     * @param {{}} root The data root to be extracted values from.\n     * @param {string} extractor The extraction string provided by the template. Usually a JSON path within the data `root`.\n     * @param {Cell} cell A reference cell, if such exists.\n     * @returns {string|number|Date|Array|Array.<Array.<*>>} The value to be used.\n     * @description This method is used even when a whole - possibly rectangular - range is about to be set, so it can\n     * return an array of arrays.\n     * @ignore\n     */\n    extractValues(root, extractor, cell) {\n        const { path, handler } = this.parseExtractor(extractor);\n\n        if (!Array.isArray(root))\n            root = _.get(root, path, root);\n        else if (root.sizes !== undefined)\n            root = !extractor ? root : _.map(root, entry => this.extractValues(entry, extractor, cell));\n        else if (!handler)\n            return root.join(this._opts.joinText || \",\");\n\n        return !handler ? root : handler.call(this._opts, root, cell);\n    }\n\n    /**\n     * Extracts an array (possibly of arrays) with data for the given fill, based on the given\n     * root object.\n     * @param {{}} root The main reference object to apply iterators to.\n     * @param {Array} iterators List of iterators - string JSON paths inside the root object.\n     * @param {Number} idx The index in the iterators array to work on.\n     * @returns {Array|Array.<Array>} An array (possibly of arrays) with extracted data.\n     * @ignore\n     */\n    extractData(root, iterators, idx) {\n        let iter = iterators[idx],\n            sizes = [],\n            transposed = false,\n            data = null;\n\n        if (iter == '1') {\n            transposed = true;\n            iter = iterators[++idx];\n        }\n\n        if (!iter) return root;\n\n        // A specific extractor can be specified after semilon - find and remember it.\n        const parsedIter = this.parseExtractor(iter);\n\n        data = _.get(root, parsedIter.path, root);\n        \n        if (typeof parsedIter.handler === 'function')\n            data = parsedIter.handler.call(this._opts, data);\n\n        if (!Array.isArray(data) && typeof data === 'object')\n            return data;\n        else if (idx < iterators.length - 1) {\n            data = _.map(data, inRoot => this.extractData(inRoot, iterators, idx + 1));\n            sizes = data[0].sizes || [];\n        }\n        \n        // data = _.values(data);\n\n        // Some data sanity checks.\n        if (!data)\n            throw new Error(`The iterator '${iter}' extracted no data!`);\n        else if (typeof data !== 'object')\n            throw new Error(`The data extracted from iterator '${iter}' is neither an array, nor object!`);\n\n        sizes.unshift(transposed ? -data.length : data.length);\n        data.sizes = sizes;\n        return data;\n    }\n\n    /**\n     * Put the data values into the proper cells, with correct extracted values.\n     * @param {{}} cell The starting cell for the data to be put.\n     * @param {Array} data The actual data to be put. The values will be _extracted_ from here first.\n     * @param {{}} template The template that is being implemented with that data fill.\n     * @returns {Array} Matrix size that this data has occupied on the sheet [rows, cols].\n     * @ignore\n     */\n    putValues(cell, data, template) {\n        if (!cell) throw new Error(\"Crash! Null reference cell in 'putValues()'!\");\n\n        let entrySize = data.sizes,\n            value = this.extractValues(data, template.extractor, cell);\n\n        // if we've come up with a raw data\n        if (!Array.isArray(value) || !entrySize || !entrySize.length) {\n            this._access.setCellValue(cell, value);\n            this.applyDataStyle(cell, data, template);\n            entrySize = template.cellSize;\n        } else if (entrySize.length <= 2) {\n            // Normalize the size and data.\n            if (entrySize[0] < 0) {\n                entrySize = [1, -entrySize[0]];\n                value = [value];\n                data = [data];\n            } else if (entrySize.length == 1) {\n                entrySize = entrySize.concat([1]);\n                value = _.chunk(value, 1);\n                data = _.chunk(data, 1);\n            }\n\n            this._access.getCellRange(cell, entrySize[0] - 1, entrySize[1] - 1).forEach((cell, ri, ci) => {\n                this._access.setCellValue(cell, value[ri][ci]);\n                this.applyDataStyle(cell, data[ri][ci], template);\n            });\n        } else\n            throw new Error(`Values extracted with '${template.extractor}' are more than 2 dimension!'`);\n\n        return entrySize;\n    }\n\n    /**\n     * Apply the given filter onto the sheet - extracting the proper data, following dependent fills, etc.\n     * @param {{}} aFill The fill to be applied, as constructed in the {@link fillData} method.\n     * @param {{}} root The data root to be used for data extraction.\n     * @param {Cell} mainCell The starting cell for data placement procedure.\n     * @returns {Array} The size of the data put in [row, col] format.\n     * @ignore\n     */\n    applyFill(aFill, root, mainCell) {\n        const template = aFill.template,\n            theData = this.extractData(root, template.iterators, 0);\n\n        let entrySize = [1, 1];\n\n        if (!aFill.dependents || !aFill.dependents.length)\n            entrySize = this.putValues(mainCell, theData, template);\n        else {\n            let nextCell = mainCell;\n            const sizeMaxxer = (val, idx) => entrySize[idx] = Math.max(entrySize[idx], val);\n\n            for (let d = 0; d < theData.length; ++d) {\n                const inRoot = theData[d];\n\n                for (let f = 0; f < aFill.dependents.length; ++f) {\n                    const inFill = aFill.dependents[f],\n                        inCell = this._access.offsetCell(nextCell, inFill.offset[0], inFill.offset[1]);\n                    \n                    _.forEach(this.applyFill(inFill, inRoot, inCell), sizeMaxxer);\n                }\n\n                // Now we have the inner data put and the size calculated.\n                _.forEach(this.putValues(nextCell, inRoot, template), sizeMaxxer);\n\n                let rowOffset = entrySize[0],\n                    colOffset = entrySize[1],\n                    rowPadding = template.padding[0] || 0,\n                    colPadding = template.padding[1] || 0;\n\n                // Make sure we grow only on one dimension.\n                if (theData.sizes[0] < 0) {\n                    if (template.padding.length < 2)\n                        colPadding = rowPadding;\n                    rowOffset = rowPadding = 0;\n                    entrySize[1] = 1;\n                } else if (theData.sizes.length < 2) {\n                    colOffset = colPadding = 0;\n                    entrySize[0] = 1;\n                }\n\n                if (rowOffset > 1 || colOffset > 1) {\n                    const rng = this._access.getCellRange(nextCell, Math.max(rowOffset - 1, 0), Math.max(colOffset - 1, 0)),\n                        _opts = this.getTemplateOpts(template);\n\n                    if (_opts.mergeCells === true || _opts.mergeCell === 'both'\n                        || rowOffset > 1 && _opts.mergeCells === 'vertical' \n                        || colOffset > 1 && _opts.mergeCells === 'horizontal')\n                        this._access.rangeMerged(rng, true);\n                    else if (_opts.duplicateCells === true || _opts.duplicateCells === 'both'\n                        || rowOffset > 1 && _opts.duplicateCells === 'vertical' \n                        || colOffset > 1 && _opts.duplicateCells === 'horizontal')\n                        this._access.duplicateCell(nextCell, rng);\n\n                    rng.forEach(cell => this.applyDataStyle(cell, inRoot, template));\n                }\n\n                // Finally, calculate the next cell.\n                nextCell = this._access.offsetCell(nextCell, rowOffset + rowPadding, colOffset + colPadding);\t\n            }\n\n            // Now recalc combined entry size.\n            _.forEach(this._access.cellDistance(mainCell, nextCell), sizeMaxxer);\n        }\n\n        _.forEach(aFill.formulas, f => this.applyFormula(f, entrySize, mainCell));\n\n        aFill.processed = true;\n        return entrySize;\n    }\n\n    /**\n     * Process a formula be shifting all the fixed offset.\n     * @param {String} formula The formula to be shifted.\n     * @param {Array<Number,Number>} offset The offset of the referenced template to the formula one.\n     * @param {Array<Number,Number>} size The size of the ranges as they should be.\n     * @returns {String} The processed text.\n     * @ignore\n     */\n    shiftFormula(formula, offset, size) {\n        let newFormula = '';\n\n        for (;;) {\n            const match = formula.match(refRegExp);\n            if (!match) break;\n\n            let from = this._access.getCell(match[3], match[2]),\n                newRef = null;\n\n            if (offset[0] > 0 || offset[1] > 0)\n                from = this._access.offsetCell(from, offset[0], offset[1]);\n\n            newRef = !match[5]\n                ? this._access.cellRef(from, !!match[2])\n                : this._access.rangeRef(this._access.getCellRange(from, size[0], size[1]), !!match[2]);\n\n            newFormula += formula.substr(0, match.index) + newRef;\n            formula = formula.substr(match.index + match[0].length);\n        }\n\n        newFormula += formula;\n        return newFormula;\n    }\n\n    /**\n     * Apply the given formula in the sheet, i.e. changing it to match the \n     * sizes of the references templates.\n     * @param {{}} aFill The fill to be applied, as constructed in the {@link fillData} method.\n     * @param {Array<Number>} entrySize The fill-to-size map, as constructed so far\n     * @param {Cell} cell The cell to put/start this formula into\n     * @returns {undefined}\n     * @ignore\n     */\n    applyFormula(aFill, entrySize, cell) {\n        cell = this._access.offsetCell(cell, aFill.offset[0], aFill.offset[1]);\n\n        const template = aFill.template,\n            iter = _.trim(template.iterators[0]),\n            offset = this._access.cellDistance(template.cell, cell);\n            \n        let formula = template.extractor, \n            rng;\n            \n        aFill.processed = true;\n        this._access.setCellValue(cell, null);\n\n        if (entrySize[0] < 2 && entrySize[1] < 2 || iter === 'both') {\n            formula = this.shiftFormula(formula, offset, [0, 0]);\n            rng = this._access.getCellRange(cell, entrySize[0] - 1, entrySize[1] - 1);\n        } else if (iter === 'cols') {\n            formula = this.shiftFormula(formula, offset, [entrySize[0] - 1, 0]);\n            rng = this._access.getCellRange(cell, 0, entrySize[1] - 1);\n        } else if (iter === 'rows') {\n            formula = this.shiftFormula(formula, offset, [0, entrySize[1] - 1]);\n            rng = this._access.getCellRange(cell, entrySize[0] - 1, 0);\n        } else { // i.e. 'none'\n            this._access.setCellFormula(cell, this.shiftFormula(formula, offset, [entrySize[0] - 1, entrySize[1] - 1]));\n            return;\n        }\n\n        this._access.setRangeFormula(rng, formula);\n    }\n}\n\n/**\n * The built-in accessor based on xlsx-populate npm module\n * @type {XlsxPopulateAccess}\n */\nXlsxDataFill.XlsxPopulateAccess = require('./XlsxPopulateAccess');\nXlsxDataFill.version = \"{{VERSION}}\";\n\nmodule.exports = XlsxDataFill;\n","\"use strict\";\n\nconst _ = require('lodash');\n\n// const allStyles = [\n//     \"bold\", \n//     \"italic\", \n//     \"underline\", \n//     \"strikethrough\", \n//     \"subscript\", \n//     \"superscript\", \n//     \"fontSize\", \n//     \"fontFamily\", \n//     \"fontGenericFamily\", \n//     \"fontScheme\", \n//     \"fontColor\", \n//     \"horizontalAlignment\", \n//     \"justifyLastLine\", \n//     \"indent\", \n//     \"verticalAlignment\", \n//     \"wrapText\", \n//     \"shrinkToFit\", \n//     \"textDirection\", \n//     \"textRotation\", \n//     \"angleTextCounterclockwise\", \n//     \"angleTextClockwise\", \n//     \"rotateTextUp\", \n//     \"rotateTextDown\", \n//     \"verticalText\", \n//     \"fill\", \n//     \"border\", \n//     \"borderColor\", \n//     \"borderStyle\", \n//     \"leftBorder\", \"rightBorder\", \"topBorder\", \"bottomBorder\", \"diagonalBorder\", \n//     \"leftBorderColor\", \"rightBorderColor\", \"topBorderColor\", \"bottomBorderColor\", \"diagonalBorderColor\", \n//     \"leftBorderStyle\", \"rightBorderStyle\", \"topBorderStyle\", \"bottomBorderStyle\", \"diagonalBorderStyle\", \n//     \"diagonalBorderDirection\", \n//     \"numberFormat\"\n// ];\n\nlet _RichText = null;\n\n/**\n * `xslx-populate` library based accessor to a given Excel workbook. All these methods are internally used by {@link XlsxDataFill}, \n * but can be used as a reference for implementing custom spreadsheet accessors.\n */\nclass XlsxPopulateAccess {\n    /**\n     * Constructs a new instance of XlsxSmartTemplate with given options.\n     * @param {Workbook} workbook - The workbook to be accessed.\n     * @param {XlsxPopulate} XlsxPopulate - The actual xlsx-populate library object.\n     * @description The `XlsxPopulate` object need to be passed in order to extract\n     * certain information from it, _without_ referring the whole library, thus\n     * avoiding making the `xlsx-datafill` package a dependency.\n     */\n    constructor(workbook, XlsxPopulate) {\n        this._workbook = workbook;\n        this._rowSizes = {};\n        this._colSizes = {};\n    \n        _RichText = XlsxPopulate.RichText;\n    }\n\n    /**\n     * Returns the configured workbook for direct XlsxPopulate manipulation.\n     * @returns {Workbook} The workbook involved.\n     */\n    workbook() {\n        return this._workbook; \n    }\n\n    /**\n     * Gets the textual representation of the cell value.\n     * @param {Cell} cell - The cell to retrieve the value from.\n     * @returns {string} The textual representation of cell's contents.\n     */\n    cellValue(cell) {\n        const theValue = cell.value();\n        return theValue instanceof _RichText ? theValue.text() : theValue;\n    }\n\n    /**\n     * Sets the cell value.\n     * @param {Cell} cell - The cell to retrieve the value from.\n     * @param {*} value - The requested value for setting.\n     * @returns {XlsxPopulateAccess} Either the requested value or chainable this.\n     */\n    setCellValue(cell, value) {\n        cell.value(value);\n        return this;\n    }\n\n    /**\n     * Gets the textual representation of the cell value.\n     * @param {Cell} cell - The cell to retrieve the value from.\n     * @returns {string} The type of the cell - 'formula', 'richtext', \n     * 'text', 'number', 'date', 'hyperlink', or 'unknown';\n     */\n    cellType(cell) {\n        if (cell.formula())\n            return 'formula';\n        else if (cell.hyperlink())\n            return 'hyperlink';\n        \n        const theValue = cell.value();\n        if (theValue instanceof _RichText)\n            return 'richtext';\n        else if (theValue instanceof Date)\n            return 'date';\n        else \n            return typeof theValue;\n    }\n\n    /**\n     * Sets the formula in the cell\n     * @param {Cell} cell - The cell to retrieve the value from.\n     * @param {string} formula - the text of the formula to be set.\n     * @returns {XlsxPopulateAccess} For chaining.\n     */\n    setCellFormula(cell, formula) {\n        cell.formula(_.trimStart(formula, ' ='));\n        return this;\n    }\n\n    /**\n     * Measures the distance, as a vector between two given cells.\n     * @param {Cell} from The first cell.\n     * @param {Cell} to The second cell.\n     * @returns {Array.<Number>} An array with two values [<rows>, <cols>], representing the distance between the two cells.\n     */\n    cellDistance(from, to) {\n        return [\n            to.rowNumber() - from.rowNumber(),\n            to.columnNumber() - from.columnNumber()\n        ];\n    }\n\n    /**\n     * Determines the size of cell, taking into account if it is part of a merged range.\n     * @param {Cell} cell The cell to be investigated.\n     * @returns {Array.<Number>} An array with two values [<rows>, <cols>], representing the occupied size.\n     */\n    cellSize(cell) {\n        const cellAddr = cell.address();\n        let theSize = [1, 1];\n    \n        _.forEach(cell.sheet()._mergeCells, range => {\n            const rangeAddr = range.attributes.ref.split(\":\");\n            if (rangeAddr[0] == cellAddr) {\n                theSize = this.cellDistance(cell, cell.sheet().cell(rangeAddr[1]));\n                ++theSize[0];\n                ++theSize[1];\n                return false;\n            }\n        });\n    \n        return theSize;\n    }\n\n    /**\n     * Sets a named style of a given cell.\n     * @param {Cell} cell The cell to be operated.\n     * @param {string} name The name of the style property to be set.\n     * @param {string|object} value The value for this property to be set.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    setCellStyle(cell, name, value) {\n        cell.style(name, value);\n        return this;\n    }\n\n    /**\n     * Creates a reference Id for a given cell, based on its sheet and address.\n     * @param {Cell} cell The cell to create a reference Id to.\n     * @param {boolean} withSheet Whether to include the sheet name in the reference. Defaults to true.\n     * @returns {string} The id to be used as a reference for this cell.\n     */\n    cellRef(cell, withSheet) {\n        if (withSheet == null)\n            withSheet = true;\n        return cell.address({ includeSheetName: withSheet });\n    }\n\n    /**\n     * Build a reference string for a cell identified by @param adr, from the @param cell.\n     * @param {Cell} cell A cell that is a base of the reference.\n     * @param {string} adr The address of the target cell, as mentioned in @param cell.\n     * @param {boolean} withSheet Whether to include the sheet name in the reference. Defaults to true.\n     * @returns {string} A reference string identifying the target cell uniquely.\n     */\n    buildRef(cell, adr, withSheet) {\n        if (withSheet == null)\n            withSheet = true;\n        return adr ? cell.sheet().cell(adr).address({ includeSheetName: withSheet }) : null;\n    }\n\n    /**\n     * Retrieves a given cell from a given sheet (or an active one).\n     * @param {string|object|array} address The cell adress to be used\n     * @param {string|idx} sheetId The id/name of the sheet to retrieve the cell from. Defaults to an active one.\n     * @returns {Cell} A reference to the required cell.\n     */\n    getCell(address, sheetId) {\n        const theSheet = sheetId == null ? this._workbook.activeSheet() : this._workbook.sheet(sheetId);\n        return theSheet.cell(address);\n    }\n\n    /**\n     * Duplicates a cell across a given range.\n     * @param {Cell} cell Cell, which needs duplicating.\n     * @param {Range} range The range, as returned from {@link getCellRange}\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    duplicateCell(cell, range) {\n        range.value(cell.value());\n        return this;\n    }\n\n    /**\n     * Constructs and returns the range starting from the given cell and spawning given rows and cells.\n     * @param {Cell} cell The starting cell of the range.\n     * @param {Number} rowOffset Number of rows away from the starting cell. 0 means same row.\n     * @param {Number} colOffset Number of columns away from the starting cell. 0 means same column.\n     * @returns {Range} The constructed range.\n     */\n    getCellRange(cell, rowOffset, colOffset) {\n        return cell.rangeTo(cell.relativeCell(rowOffset, colOffset));\n    }\n\n    /**\n     * Gets the cell at a certain offset from a given one.\n     * @param {Cell} cell The reference cell to make the offset from.\n     * @param {int} rows Number of rows to offset.\n     * @param {int} cols Number of columns to offset.\n     * @returns {Cell} The resulting cell.\n     */\n    offsetCell(cell, rows, cols) {\n        return cell.relativeCell(rows, cols);\n    }\n\n    /**\n     * Merge or split range of cells.\n     * @param {Range} range The range, as returned from {@link getCellRange}\n     * @param {boolean} status The merged status to be set.\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    rangeMerged(range, status) {\n        if (status === undefined)\n            return range.merged();\n        else {\n            range.merged(status);\n            return this;\n        }\n    }\n\n    /**\n     * Sets a formula for the whole range. If it contains only one - it is set directly.\n     * @param {Range} range The range, as returned from {@link getCellRange}\n     * @param {String} formula The formula to be set.\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    setRangeFormula(range, formula) {\n        range.formula(_.trimStart(formula, ' ='));\n        return this;\n    }\n\n    /**\n     * Return the string representation of a given range.\n     * @param {Range} range The range which address we're interested in.\n     * @param {boolean} withSheet Whether to include sheet name in the address.\n     * @return {String} The string, representing the given range.\n     */\n    rangeRef(range, withSheet) {\n        if (withSheet == null)\n            withSheet = true;\n        return range.address({ includeSheetName: withSheet });\n    }\n\n    /**\n     * Iterate over all used cells of the given workbook.\n     * @param {function} cb The callback to be invoked with `cell` argument for each used cell.\n     * @returns {XlsxPopulateAccess} For chain invokes.\n     */\n    forAllCells(cb) {\n        this._workbook.sheets().forEach(sheet => {\n            const theRange = sheet.usedRange();\n            if (theRange) \n                theRange.forEach(cb);\n        });\n        return this;\n    }\n\n    /**\n     * Copies the styles from `src` cell to the `dest`-ination one.\n     * @param {Cell} dest Destination cell.\n     * @param {Cell} src Source cell.\n     * @returns {XlsxPopulateAccess} For invocation chaining.\n     */\n    copyStyle(dest, src) {\n        if (!src || !dest) throw new Error(\"Crash! Null 'src' or 'dest' for copyStyle()!\");\n        if (src == dest) return this;\n\n        if (src._style !== undefined)\n            dest.style(src._style);\n        else if (src._styleId > 0)\n            dest._styleId = src._styleId;\n\n        const destSheetId = dest.sheet().name(),\n            rowId = `'${destSheetId}':${dest.rowNumber()}`,\n            colId = `'${destSheetId}':${dest.columnNumber()}`;\n\n        if (this._rowSizes[rowId] === undefined)\n            dest.row().height(this._rowSizes[rowId] = src.row().height());\n        \n        if (this._colSizes[colId] === undefined)\n            dest.column().width(this._colSizes[colId] = src.column().width());\n\n        return this;\n    }\n}\n\nmodule.exports = XlsxPopulateAccess;\n"]}